#!/opt/bb/bin/bash

##
## Various checks, pre-commit
##

usage ()
{
    echo "Usage: pre-commit [-a] [--tags] [--verbose] [--help] [--skip ... [ --skip ... ] ]"
    echo "       -a     - mimic the -a of git commit and process files that are modified"
    echo "                in addition to those that have been added (staged)"
    echo "       --tags - print all the tags that trip this check"
    echo "       --verbose - print progress"
    echo "       --help - this message"
    echo "       --skip - skip one or more validations:"
    echo "                perlcompile"
    echo "                perltidy"
    echo "       When actually run as a hook, set GIT_PRE_COMMIT_HOOK_ARGS to a single"
    echo "       string with the options you want to use before committing:"
    echo
    echo "       GIT_PRE_COMMIT_HOOK_ARGS='--verbose --skip perltidy' git commit ..."
    echo
}

## Don't do my checks if Perl testing involves git commands.
[ "$HARNESS_ACTIVE" = '1' ] && exit 0


pre_commit_ok_echo ()
{
    echo pre-commit hook: "$@"
}

pre_commit_error_echo ()
{
    echo 'ERROR>>>' pre-commit hook: "$@"
}

## See if we are in a real commit or not
typeset dry_run=0
if [ -z "$GIT_AUTHOR_DATE" ]
then
    dry_run=1
    pre_commit_ok_echo "Dry run mode - no commit in progress."
fi

##
## args and opts
##
typeset -A skips
typeset opt_verbose=1
typeset opt_a=0
typeset OPTSARGS=$(getopt -o ats:vh --long tags,skip:,verbose,help -n 'pre-commit' -- $GIT_PRE_COMMIT_HOOK_ARGS "$@")
eval set -- "$OPTSARGS"
while true
do
    case "$1" in
        -a)
            shift
            opt_a=1 ;;
        -t|--tags)
            shift
            grep '##tags' ${BASH_SOURCE[0]} | sed 's/##tags//' | grep -v grep
            exit 0 ;;
        -s|--skip)
            shift
            skips[$1]=1;
            shift ;;
        -v|--verbose)
            shift
            opt_verbose=1 ;;
        -h|--help)
            usage
            exit 0 ;;
        --) shift; break ;; ## end of opts, remaining $*, if any, are args
        *) echo "Internal error!"; usage; exit 1 ;;
    esac
done

##
## inits and globals
##

## We use a temp file to process output instead of $() capturing so we don't
## lose the newlines...
typeset tfile=$(mktemp)

## ...and we set up a trap for cleanup
trap finish EXIT SIGINT

## Assume correctness
typeset exitval=0

##
## Functions
##

finish ()
{
    if [ -e $tfile ]
    then
        rm -rf $tfile
    fi
}

check ()
{
    local tfile=$1
    shift
    local tcount=$(wc -l $tfile | sed 's/ .*//')
    if [ $tcount != 0 ]
    then
        ## This is the error message
        echo
        pre_commit_error_echo "$1"
        cat $tfile
        exitval=1
        return 1
    else
        ## This is the ok message
        [ -n "$2" ] && ((opt_verbose==1)) && pre_commit_ok_echo "$2"
        return 0
    fi
}

##
## Main
##

## Get the top level dir of the repo
typeset tl=$(git rev-parse --show-toplevel)
typeset files
if ((opt_a))
then
    ## Like git's -a, process modified files even if not 'git add'ed
    files=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^[ACM] / or m/^.[ACM]/')
else
    files=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^[ACM] /')
fi
typeset delfiles=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^D /')
typeset huhfiles=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^\? /')

if ((opt_verbose))
then
    typeset tmpf=$(mktemp)
    git status --porcelain 1>$tmpf 2>&1
    if [ -s $tmpf ]
    then
        pre_commit_ok_echo Current status:
        cat $tmpf
    fi
    \rm -f $tmpf

    typeset fcount=$(echo $files | wc -w)
    typeset text='files to process'
    ((fcount == 1 )) && text='file to process'
    pre_commit_ok_echo $fcount $text

    fcount=$(echo $delfiles | wc -w)
    text='files to be skipped because they are being deleted'
    if ((fcount))
    then
        ((fcount == 1 )) && text='file to be skipped because it is being deleted'
        echo pre-commit  hook: $fcount $text
    fi

    fcount=$(echo $huhfiles | wc -w)
    text='files to be skipped because they are not being tracked'
    if ((fcount))
    then
        ((fcount == 1 )) && text='file to be skipped because it is not being tracked'
        echo pre-commit  hook: $fcount $text
    fi
fi

## Isolate groups of files here. So far, only checking for Perl.
typeset perlfiles
typeset file
for file in $files
do
    head -1 $file | grep perl | grep -E '^#!' > /dev/null
    if [ "$?" == '0' ]
    then
        perlfiles="$perlfiles $file"
    else
        echo $file | grep -iE '\.(p[ml]|t|sgi)$' > /dev/null
        if [ "$?" == '0' ]
        then
            perlfiles="$perlfiles $file"
        fi
    fi
done

##
## The tests...
##

if [ -n "$files" ]
then
    touch $tfile

    ##
    ## check: files being edited, not saved
    ##
    for i in $files
    do
        emacsfile="$(dirname $(realpath $i))/.#$(basename $i)"
        if [ -h $emacsfile ]
        then
            echo $i >> $tfile
        fi
    done
    check $tfile \
          "Write your emacs buffers for these files:" \
          "No open emacs buffers."

    ##
    ## check: constructs for bypassed or dead code
    ##

    ## These two are Perl constructs, but we could use them temporarily in any
    ## file type.
    grep -H -n -E -i '=for (later|comparison|commentout|review)' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Delete old code, do not just comment it out. Don't add inactive code until you are ready to use it." \
          "No suspicious Perl commenting, old code."

    grep -H -n -E -i '=for (remove|restore)_before_commit' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Put back original code; remove your short term test changes." \
          "No suspicious Perl commenting, test code."

    if [ -n "$perlfiles" ]
    then
        ##
        ## These are Perl constructs that only make sense in Perl code.
        ##

        ##
        ## check: Perl debug statements
        ##
        grep -H -n -E '\$DB::s(ingle|tep)' $perlfiles 1>$tfile 2>&1
        check $tfile \
              "One or more files has Perl-debugger-related statements. Please remove instrumentation." \
              "No Perl-debugger-related statements."

        ##
        ## check: testing utilities left in the code
        ##
        grep -H -n -E 'TestingUtils' $perlfiles | grep -v TestingUtils.pm  1>$tfile 2>&1
        check $tfile \
              "One or more files is using the TestingUtils module. Please remove it." \
              "TestingUtils module not found."

        gitroot=$(git rev-parse --show-toplevel)

        ##
        ## check: repo compile tests
        ##

        ## If the repo has them, piggy back off of them
        if [ -n "${skips[perlcompile]}" ]
        then
            ((opt_verbose)) && pre_commit_ok_echo "Skipping Perl compile check, by request."
        elif [ ! -e $gitroot/t/bin/apply-compile-check-everywhere ]
        then
            ((opt_verbose)) && pre_commit_ok_echo "Skipping Perl compile check, no test file."
        else
            cartonexec=''
            if [ -e $gitroot/runtests.local ]
            then
                pre_commit_ok_echo "Sourcing $gitroot/runtests.local for perl compile tests."
                . /$gitroot/runtests.local
                if [ "$RUNTESTS_USE_CARTON" = '1' ]
                then
                    cartonexec='carton exec'
                fi
            fi
            $cartonexec $gitroot/t/bin/apply-compile-check-everywhere $perlfiles 1>$tfile 2>&1
            check $tfile \
                  "One or more files has syntax errors. Please check." \
                  "No Perl compile errors."
        fi

        ##
        ## check: repo tidy tests
        ##

        ## If the repo has them, piggy back off of them
        if [ -n "${skips[perltidy]}" ]
        then
            ((opt_verbose)) && pre_commit_ok_echo "Skipping Perl perltidy check, by request."
        elif [ ! -e $gitroot/t/bin/apply-perltidy-everywhere ]
        then
            ((opt_verbose)) && pre_commit_ok_echo "Skipping Perl perltidy check, no test file."
        else
            $gitroot/t/bin/apply-perltidy-everywhere $perlfiles 1>$tfile 2>&1
            check $tfile \
                  "One or more files has formatting errors. Please check." \
                  "No Perl perltidy errors."
        fi
    fi

    ##
    ## check; git conflict markers
    ##
    grep -H -n -E '^<<<<<<<|>>>>>>>$' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contains a git conflict marker. Please address." \
          "No git conflict markers."

    ##
    ## check: git commit stop check
    ##

    ## As a last resort, we allow the text strings <gitcommitstop> and <GCS>,
    ## usually as comment in the given language, to be used to stop the commit
    ## of code that we know we need to clean up before committing. In the
    ## limited number of utilities that manipulate files with GCS, we add the
    ## GCSLITERAL caveat.
    grep -H -n -E '<(gitcommitstop|GCS)>' $files | grep -v '<GCSLITERAL>' 1>$tfile 2>&1
    check $tfile \
          "One or more files has an explicit commit stop. Please address." \
          "No explicit commit stops."
fi

##
## Done
##
if ((exitval==0))
then
    pre_commit_ok_echo "Ok to commit"
else
    pre_commit_error_echo "Commit will abort"
fi
exit $exitval

##tags emacs backup files\.
##tags     '.#*'
##tags Perl multiline comments.
##tags     '=for (later|comparison|comment|review)'
##tags     '=for (remove|restore)_before_commit'
##tags Perl debugger statements.
##tags     '$DB::s(ingle|tep)'
##tags The presence of the testing module TestingUtils.
##tags     use TestingUtils
##tags Explicit commit stop. Add as a comment in
##tags the given language. Perl examples:
##tags     '$foo=bar; ## <gitcommitstop> dev only'
##tags     '$foo=bar; ## <GCS> dev only'
##tags t/bin/apply-compile-check-everywhere
##tags t/bin/apply-perltidy-everywhere
##tags     Run these tests, if available.
