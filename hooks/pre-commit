#!/opt/bb/bin/bash

##
## Various checks, pre-commit
##

usage ()
{
    echo "Usage: pre-commit [--tags] [ --edit] [--verbose] [--help]"
    echo "       --tags - print all the tags that trip this check"
    echo "       --edit - edit all files that trip this check"
    echo "       --verbose - print progress"
    echo "       --help - this message"
}

##
## args and opts
##
typeset opt_edit=0
typeset opt_verbose=0
typeset OPTSARGS=$(getopt -o tevh --long tags,edit,verbose,help -n 'pre-commit' -- "$@")
eval set -- "$OPTSARGS"
while true
do
    case "$1" in
        -t|--tags)
            shift
            grep '##tags' ${BASH_SOURCE[0]} | sed 's/##tags//' | grep -v grep
            exit 0 ;;
        -e|--edit)
            shift
            opt_edit=1 ;;
        -v|--verbose)
            shift
            opt_verbose=1 ;;
        -h|--help)
            usage
            exit 0 ;;
        --) shift; break ;; ## end of opts, remaining $*, if any, are args
        *) echo "Internal error!"; usage; return 1 ;;
    esac
done

##
## inits and globals
##

## We use a temp file to process output instead of $() capturing so we don't
## lose the newlines...
typeset tfile=$(mktemp)

## ...and we set up a trap for cleanup
trap finish EXIT SIGINT

## Assume correctness
typeset exitval=0

##
## Functions
##

finish ()
{
    if [ -e $tfile ]
    then
        rm -rf $tfile
    fi
}

check ()
{
    local tfile=$1
    shift
    local tcount=$(wc -l $tfile | sed 's/ .*//')
    if [ $tcount != 0 ]
    then
        echo
        echo "pre-commit hook: $*"
        cat $tfile
        exitval=1
        return 1
    else
        return 0
    fi
}

typeset editlist=''
addedit ()
{
    local tfile=$1
    shift
    editlist="$(echo $editlist $(cat $tfile | sed 's/:.*//') | tr ' ' '\n' | sort -u)"
}

##
## Main
##

## Get the top level of the Where are we?
typeset tl=$(git rev-parse --show-toplevel)
typeset potentials
if [ -z "$1" ]
then
    ## Figure out what could be committed from the current state of the repo.
    ((opt_verbose)) && echo "Looking for files..."
    potentials=$(git st --porcelain -uno | sed 's/.* //')
#    potentials=$(git diff | grep -- 'diff --git' | cut -d' ' -f 4 | sed 's|b/||')
else
    ## Use whatever is on the command line, probably as a manual pre-commit check.
    potentials="$@"
fi

typeset f
for f in $potentials
do
    if [ -f $f ]
    then
        files="$files $f"
    elif [ -d $f ]
    then
        dirs="$dirs $f"
        files="$files $(find $f -type f)"
    fi
done

if ((opt_verbose))
then
    fcount=$(echo $files | wc -l)
    text='files to process'
    ((fcount == 1 )) && text='file to process'
    echo $fcount $text
fi

for file in $files
do
    head -1 $file | grep perl | grep -E '^#!' > /dev/null
    if [ "$?" == '0' ]
    then
        perlfiles="$perlfiles $file"
    else
        echo $file | grep -iE '\.(p[ml]|t|sgi)$' > /dev/null
        if [ "$?" == '0' ]
        then
            perlfiles="$perlfiles $file"
        fi
    fi
done

##
## The tests...
##

## Make sure all emacs buffers are written.
find -P $tl -name \.#\* 1>$tfile 2>&1
check $tfile \
      "Write your emacs buffers corresponding to these emacs backup files first."

##
## These are Perl constructs, but we could use them temporarily in any file
## type.
##

if [ -n "$files" ]
then
    ## Make sure we have no Perl commented out code.
    grep -H -n -E '=for (later|comparison|comment)' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Delete old code, do not just comment it out. Don't add inactive code until you are ready to use it."
    ## Can't addedit $tfile here because it's the emacs backup, not the master, in the file.

    grep -H -n -E '=for (remove|restore)_before_commit' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Put back original code; remove your short term test changes."
    [ "$?" = '1' ] && addedit $tfile

    ##
    ## These are Perl constructs that only make sense in Perl code.
    ##

    if [ -n "$perlfiles" ]
    then
        ## Make sure we have no Perl debug statements.
        grep -H -n -E '\$DB::s(ingle|tep)' $perlfiles 1>$tfile 2>&1
        check $tfile \
              "One or more files has Perl-debugger-related statements. Please remove instrumentation."
        [ "$?" = '1' ] && addedit $tfile

        ## Make sure we turn back on any taints we commented out for testing. Make sure
        ## we don't grab the shebang line (which would contain the word 'perl').
        grep -H -n -E '^#.*-.*T' $perlfiles | grep -v perl 1>$tfile 2>&1
        check $tfile \
              "One or more files has its taint flag commented out. Please restore it."
        [ "$?" = '1' ] && addedit $tfile

        ## Check for testing utils
        grep -H -n -E 'TestingUtils' $perlfiles | grep -v TestingUtils.pm  1>$tfile 2>&1
        check $tfile \
              "One or more files is using the TestingUtils module. Please remove it."
        [ "$?" = '1' ] && addedit $tfile

    fi

    ## As a last resort, we allow the text strings <gitcommitstop> and <GCS>,
    ## usually as comment in the given language
    grep -H -n -E '<gitcommitstop|GCS>' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files has an explicit commit stop. Please address."
    [ "$?" = '1' ] && addedit $tfile
fi

##
## Done
##
if [ -n "$editlist" ] && ((opt_edit))
then
    echo
    echo "-e|--edit specified. Editing"
    echo "$editlist"
    xo $editlist
fi

if ((opt_verbose))
then
    elcount=$(echo $editlist | wc -w)
    text="$elcount files to be fixed"
    ((elcount == 1)) && text="$elcount file to be fixed"
    echo
    echo $text
fi

exit $exitval

##tags emacs backup files\.
##tags     '.#*'
##tags Perl multiline comments.
##tags     '=for (later|comparison|comment)'
##tags     '=for (remove|restore)_before_commit'
##tags Perl debugger statements.
##tags     '$DB::s(ingle|tep)'
##tags Perl taint checks turned off (debugging).
##tags     '^#.*-.*T'
##tags The presence of the testing module TestingUtils.
##tags     use TestingUtils
##tags Explicit commit stop. Add as a comment in
##tags the given language. Perl examples:
##tags     '$foo=bar; ## <gitcommitstop> dev only'
##tags     '$foo=bar; ## <GCS> dev only'
