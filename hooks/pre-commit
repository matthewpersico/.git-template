#!/opt/bb/bin/bash

##
## Various checks, pre-commit
##

usage ()
{
    echo "Usage: pre-commit [--tags] [--verbose] [--help]"
    echo "       --tags - print all the tags that trip this check"
    echo "       --verbose - print progress"
    echo "       --help - this message"
}

##
## args and opts
##
typeset opt_verbose=1
typeset OPTSARGS=$(getopt -o tevh --long tags,verbose,help -n 'pre-commit' -- "$@")
eval set -- "$OPTSARGS"
while true
do
    case "$1" in
        -t|--tags)
            shift
            grep '##tags' ${BASH_SOURCE[0]} | sed 's/##tags//' | grep -v grep
            exit 0 ;;
        -v|--verbose)
            shift
            opt_verbose=1 ;;
        -h|--help)
            usage
            exit 0 ;;
        --) shift; break ;; ## end of opts, remaining $*, if any, are args
        *) echo "Internal error!"; usage; return 1 ;;
    esac
done

##
## inits and globals
##

## We use a temp file to process output instead of $() capturing so we don't
## lose the newlines...
typeset tfile=$(mktemp)

## ...and we set up a trap for cleanup
trap finish EXIT SIGINT

## Assume correctness
typeset exitval=0

##
## Functions
##

finish ()
{
    if [ -e $tfile ]
    then
        rm -rf $tfile
    fi
}

check ()
{
    local tfile=$1
    shift
    local tcount=$(wc -l $tfile | sed 's/ .*//')
    if [ $tcount != 0 ]
    then
        echo
        echo "pre-commit hook: $*"
        cat $tfile
        exitval=1
        return 1
    else
        return 0
    fi
}

pre_commit_echo ()
{
    echo pre-commit hook: "$@"
}

##
## Main
##

## Get the top level of the Where are we?
typeset tl=$(git rev-parse --show-toplevel)
typeset files=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^[ACM] /')
typeset delfiles=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^D /')
typeset huhfiles=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^\? /')

if ((opt_verbose))
then
    pre_commit_echo Current status
    git status --porcelain

    fcount=$(echo $files | wc -w)
    text='files to process'
    ((fcount == 1 )) && text='file to process'
    pre_commit_echo $fcount $text

    fcount=$(echo $delfiles | wc -w)
    text='files to be skipped because they are being deleted'
    if ((fcount))
    then
        ((fcount == 1 )) && text='file to be skipped because it is being deleted'
        echo pre-commit  hook: $fcount $text
    fi

    fcount=$(echo $huhfiles | wc -w)
    text='files to be skipped because they are not being tracked'
    if ((fcount))
    then
        ((fcount == 1 )) && text='file to be skipped because it is not being tracked'
        echo pre-commit  hook: $fcount $text
    fi
fi

for file in $files
do
    head -1 $file | grep perl | grep -E '^#!' > /dev/null
    if [ "$?" == '0' ]
    then
        perlfiles="$perlfiles $file"
    else
        echo $file | grep -iE '\.(p[ml]|t|sgi)$' > /dev/null
        if [ "$?" == '0' ]
        then
            perlfiles="$perlfiles $file"
        fi
    fi
done

##
## The tests...
##

## Make sure all emacs buffers are written, regardless of whether or not its
## corresponding file is being committed.
find -P $tl -name \.#\* 1>$tfile 2>&1
check $tfile \
      "Write your emacs buffers corresponding to these emacs backup files first."

##
## These are Perl constructs, but we could use them temporarily in any file
## type.
##

if [ -n "$files" ]
then
    ## Make sure we have no Perl commented out code.
    grep -H -n -E '=for (later|comparison|comment)' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Delete old code, do not just comment it out. Don't add inactive code until you are ready to use it."

    grep -H -n -E '=for (remove|restore)_before_commit' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Put back original code; remove your short term test changes."

    ##
    ## These are Perl constructs that only make sense in Perl code.
    ##

    if [ -n "$perlfiles" ]
    then
        ## Make sure we have no Perl debug statements.
        grep -H -n -E '\$DB::s(ingle|tep)' $perlfiles 1>$tfile 2>&1
        check $tfile \
              "One or more files has Perl-debugger-related statements. Please remove instrumentation."

        ## Make sure we turn back on any taints we commented out for testing. Make sure
        ## we don't grab the shebang line (which would contain the word 'perl').
        grep -H -n -E '^#.*-.*T' $perlfiles | grep -v perl 1>$tfile 2>&1
        check $tfile \
              "One or more files has a pattern that matches a commented out taint flag. Please 1restore it."

        ## Check for testing utils
        grep -H -n -E 'TestingUtils' $perlfiles | grep -v TestingUtils.pm  1>$tfile 2>&1
        check $tfile \
              "One or more files is using the TestingUtils module. Please remove it."

        gitroot=$(git rev-parse --show-toplevel)

        ## Check for perl tests
        if [ -e $gitroot/t/bin/apply-compile-check-everywhere ]
        then
            ((verbose)) && echo "Checking perl code for errors"
            $gitroot/t/bin/apply-compile-check-everywhere $perlfiles 1>$tfile 2>&1
            check $tfile \
                  "One or more files has syntax errors. Please check."
        fi

        ## Check for perl tests
        if [ -e $gitroot/t/bin/apply-perltidy-everywhere ]
        then
            ((verbose)) && echo "Checking perl code for format"
            $gitroot/t/bin/apply-perltidy-everywhere $perlfiles 1>$tfile 2>&1
            check $tfile \
                  "One or more files has formatting errors. Please check."
        fi
    fi

    ## As a last resort, we allow the text strings <gitcommitstop> and <GCS>,
    ## usually as comment in the given language
    grep -H -n -E '<gitcommitstop|GCS>' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files has an explicit commit stop. Please address."
fi

##
## Done
##
exit $exitval

##tags emacs backup files\.
##tags     '.#*'
##tags Perl multiline comments.
##tags     '=for (later|comparison|comment)'
##tags     '=for (remove|restore)_before_commit'
##tags Perl debugger statements.
##tags     '$DB::s(ingle|tep)'
##tags Perl taint checks turned off (debugging).
##tags     '^#.*-.*T'
##tags The presence of the testing module TestingUtils.
##tags     use TestingUtils
##tags Explicit commit stop. Add as a comment in
##tags the given language. Perl examples:
##tags     '$foo=bar; ## <gitcommitstop> dev only'
##tags     '$foo=bar; ## <GCS> dev only'
