#!/opt/bb/bin/bash

##
## Various checks, pre-commit
##

usage ()
{
    echo "Usage: pre-commit [--tags] [--verbose] [--help] [--skip ... [ --skip ... ] ]"
    echo "       --tags - print all the tags that trip this check"
    echo "       --verbose - print progress"
    echo "       --help - this message"
    echo "       --skip - skip one or more validations:"
    echo "                perlcompile"
    echo "                perltidy"
    echo "                perltaint"
    echo "       When actually run as a hook, set GIT_PRE_COMMIT_HOOK_ARGS to a single"
    echo "       string with the options you want to use before committing:"
    echo
    echo "       GIT_PRE_COMMIT_HOOK_ARGS='--verbose --skip perltidy' git commit ..."
    echo
}

## Don't do my checks if Perl testing involves git commands.
[ "$HARNESS_ACTIVE" = '1' ] && exit 0

##
## args and opts
##
typeset -A skips
typeset opt_verbose=1
typeset OPTSARGS=$(getopt -o ts:vh --long tags,skip:,verbose,help -n 'pre-commit' -- $GIT_PRE_COMMIT_HOOK_ARGS "$@")
eval set -- "$OPTSARGS"
while true
do
    case "$1" in
        -t|--tags)
            shift
            grep '##tags' ${BASH_SOURCE[0]} | sed 's/##tags//' | grep -v grep
            exit 0 ;;
        -s|--skip)
            shift
            skips[$1]=1;
            shift ;;
        -v|--verbose)
            shift
            opt_verbose=1 ;;
        -h|--help)
            usage
            exit 0 ;;
        --) shift; break ;; ## end of opts, remaining $*, if any, are args
        *) echo "Internal error!"; usage; exit 1 ;;
    esac
done

##
## inits and globals
##

## We use a temp file to process output instead of $() capturing so we don't
## lose the newlines...
typeset tfile=$(mktemp)

## ...and we set up a trap for cleanup
trap finish EXIT SIGINT

## Assume correctness
typeset exitval=0

##
## Functions
##

finish ()
{
    if [ -e $tfile ]
    then
        rm -rf $tfile
    fi
}

pre_commit_echo ()
{
    echo pre-commit hook: "$@"
}

check ()
{
    local tfile=$1
    shift
    local tcount=$(wc -l $tfile | sed 's/ .*//')
    if [ $tcount != 0 ]
    then
        echo
        pre_commit_echo "$1"
        cat $tfile
        exitval=1
        return 1
    else
        [ -n "$2" ] && ((opt_verbose==1)) && pre_commit_echo "$2"
        return 0
    fi
}

##
## Main
##

## Get the top level of the Where are we?
typeset tl=$(git rev-parse --show-toplevel)
typeset files=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^[ACM] /')
typeset delfiles=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^D /')
typeset huhfiles=$(git status --porcelain  | perl -ane 'print $F[1],qq(\n) if m/^\? /')

if ((opt_verbose))
then
    tmpf=$(mktemp)
    git status --porcelain 1>$tmpf 2>&1
    if [ -s $tmpf ]
    then
        pre_commit_echo Current status:
        cat $tmpf
    fi
    \rm -f $tmpf

    fcount=$(echo $files | wc -w)
    text='files to process'
    ((fcount == 1 )) && text='file to process'
    pre_commit_echo $fcount $text

    fcount=$(echo $delfiles | wc -w)
    text='files to be skipped because they are being deleted'
    if ((fcount))
    then
        ((fcount == 1 )) && text='file to be skipped because it is being deleted'
        echo pre-commit  hook: $fcount $text
    fi

    fcount=$(echo $huhfiles | wc -w)
    text='files to be skipped because they are not being tracked'
    if ((fcount))
    then
        ((fcount == 1 )) && text='file to be skipped because it is not being tracked'
        echo pre-commit  hook: $fcount $text
    fi
fi

for file in $files
do
    head -1 $file | grep perl | grep -E '^#!' > /dev/null
    if [ "$?" == '0' ]
    then
        perlfiles="$perlfiles $file"
    else
        echo $file | grep -iE '\.(p[ml]|t|sgi)$' > /dev/null
        if [ "$?" == '0' ]
        then
            perlfiles="$perlfiles $file"
        fi
    fi
done

##
## The tests...
##

if [ -n "$files" ]
then
    touch $tfile
    for i in $files
    do
        emacsfile="$(dirname $(realpath $i))/.#$(basename $i)"
        if [ -h $emacsfile ]
        then
            echo $i >> $tfile
        fi
    done
    check $tfile \
          "Write your emacs buffers for these files:" \
          "No open emacs buffers."

    ##
    ## These two are Perl constructs, but we could use them temporarily in any
    ## file type.
    ##
    grep -H -n -E '=for (later|comparison|comment)' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Delete old code, do not just comment it out. Don't add inactive code until you are ready to use it." \
          "No suspicious Perl commenting, old code."

    grep -H -n -E '=for (remove|restore)_before_commit' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files contain suspicious Perl commenting. Put back original code; remove your short term test changes." \
          "No suspicious Perl commenting, test code."

    if [ -n "$perlfiles" ]
    then
        ##
        ## These are Perl constructs that only make sense in Perl code.
        ##

        ## Make sure we have no Perl debug statements.
        grep -H -n -E '\$DB::s(ingle|tep)' $perlfiles 1>$tfile 2>&1
        check $tfile \
              "One or more files has Perl-debugger-related statements. Please remove instrumentation." \
              "No Perl-debugger-related statements."

        ## Make sure we turn back on any taints we commented out for testing. Make sure
        ## we don't grab the shebang line (which would contain the word 'perl').
        if [ -z "${skips[perltaint]}" ]
        then
            grep -H -n -E '^#.*-.*T' $perlfiles | grep -v perl 1>$tfile 2>&1
            check $tfile \
                  "One or more files has a pattern that matches a commented out taint flag. Please restore it." \
                  "No commented out taint flags."
        elif((opt_verbose))
        then
            pre_commit_echo "Skipping Perl taint flag check, by request."
        fi

        ## Check for testing utils
        grep -H -n -E 'TestingUtils' $perlfiles | grep -v TestingUtils.pm  1>$tfile 2>&1
        check $tfile \
              "One or more files is using the TestingUtils module. Please remove it." \
              "TestingUtils module not found."

        gitroot=$(git rev-parse --show-toplevel)

        ## Check for perl tests
        if [ -z "${skips[perlcompile]}" ] && [ -e $gitroot/t/bin/apply-compile-check-everywhere ]
        then
            $gitroot/t/bin/apply-compile-check-everywhere $perlfiles 1>$tfile 2>&1
            check $tfile \
                  "One or more files has syntax errors. Please check." \
                  "No Perl compile errors."
        elif((opt_verbose))
        then
            pre_commit_echo "Skipping Perl compile check, by request."
        fi

        ## Check for perl tests
        if [ -z "${skips[perltidy]}" ] && [ -e $gitroot/t/bin/apply-perltidy-everywhere ]
        then
            $gitroot/t/bin/apply-perltidy-everywhere $perlfiles 1>$tfile 2>&1
            check $tfile \
                  "One or more files has formatting errors. Please check." \
                  "No Perl perltidy errors."
        elif((opt_verbose))
        then
            pre_commit_echo "Skipping Perl perltidy check, by request."
        fi
    fi

    ## As a last resort, we allow the text strings <gitcommitstop> and <GCS>,
    ## usually as comment in the given language
    grep -H -n -E '<gitcommitstop|GCS>' $files 1>$tfile 2>&1
    check $tfile \
          "One or more files has an explicit commit stop. Please address." \
          "No explicit commit stops."
fi

##
## Done
##
exit $exitval

##tags emacs backup files\.
##tags     '.#*'
##tags Perl multiline comments.
##tags     '=for (later|comparison|comment)'
##tags     '=for (remove|restore)_before_commit'
##tags Perl debugger statements.
##tags     '$DB::s(ingle|tep)'
##tags Perl taint checks turned off (debugging).
##tags     '^#.*-.*T'
##tags The presence of the testing module TestingUtils.
##tags     use TestingUtils
##tags Explicit commit stop. Add as a comment in
##tags the given language. Perl examples:
##tags     '$foo=bar; ## <gitcommitstop> dev only'
##tags     '$foo=bar; ## <GCS> dev only'
##tags t/bin/apply-compile-check-everywhere
##tags t/bin/apply-perltidy-everywhere
##tags     Run these tests, if available.
